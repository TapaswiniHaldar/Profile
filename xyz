package com.example.utility1.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.mongodb.core.MongoTemplate;
import com.mongodb.client.MongoClients;

@Configuration
public class MongoConfig {

    @Bean
    public MongoTemplate mongoTemplate() {
        return new MongoTemplate(MongoClients.create("mongodb://localhost:27017"), "utility");
    }
}


package com.example.utility1.constants;

/**
 * Constants used in ProposalService.
 */
public class Constants {

    // Proposal Status Constants
    public static final String STATUS_REJECTED = "REJECTED";
    public static final String STATUS_INPROGRESS = "INPROGRESS";
    public static final String STATUS_PENDING = "PENDING";
    public static final String STATUS_UPDATED = "UPDATED";
    public static final String STATUS_NOT_FOUND = "NOT FOUND";

    // Remarks Constants
    public static final String REMARKS_PURGED = "Will be purged";

    // Message Constants
    public static final String MESSAGE_NO_RECORDS_FOUND = "No records found for proposal id: {}";
    public static final String MESSAGE_UPDATE_SUCCESS = "Updated {} record(s) for proposal id: {} â†’ status set to {}";
    public static final String MESSAGE_FILE_PROCESS_ERROR = "Error processing file: {}";
    public static final String MESSAGE_ROW_PROCESS_ERROR = "Error processing row: {}";
    public static final String MESSAGE_TECHNICAL_ERROR = "Technical error due to I/O or DB issue.";
    public static final String MESSAGE_EXCEL_PROCESS_ERROR = "Error processing Excel file: {}";  // Added this constant
    private Constants() {
        // Private constructor to prevent instantiation
    }
}




package com.example.utility1.controller;

import com.example.utility1.constants.Constants;
import com.example.utility1.model.Proposal;
import com.example.utility1.model.ProposalStatus;
import com.example.utility1.service.ProposalService;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;

/**
 * REST Controller for managing Proposal records.
 */
@RestController
@RequestMapping("/api/proposal")
@RequiredArgsConstructor
public class ProposalController {

    private final ProposalService proposalService;
    private static final Logger logger = LoggerFactory.getLogger(ProposalController.class);

    /**
     * Upload and process an Excel file to update Proposal records.
     */
    @PostMapping("/upload")
    public ResponseEntity<String> uploadExcel(@RequestParam("file") MultipartFile file) {
        try {
            List<Proposal> proposals = proposalService.createProposals(file);
            return ResponseEntity.ok("Excel processed successfully. Updated status where necessary.");
        } catch (Exception e) {
            logger.error("Error processing file upload: {}", e.getMessage());
            return ResponseEntity.status(500).body(Constants.MESSAGE_TECHNICAL_ERROR);
        }
    }

    /**
     * Update a single Proposal record based on ProposalId.
     */
    @PutMapping("/update/{proposalId}")
    public ResponseEntity<List<ProposalStatus>> updateProposalStatus(@PathVariable String proposalId) {
        try {
            proposalService.updateProposalStatusById(proposalId);
            List<ProposalStatus> statusHistory = proposalService.getStatusHistory(proposalId);
            return ResponseEntity.ok(statusHistory);
        } catch (Exception e) {
            logger.error("Error updating proposal status for {}: {}", proposalId, e.getMessage());
            return ResponseEntity.status(500).body(List.of(
                    new ProposalStatus(null, proposalId, "N/A", Constants.MESSAGE_TECHNICAL_ERROR)
            ));
        }
    }

    /**
     * Bulk update multiple Proposals using a file.
     */
    @PutMapping("/update")
    public ResponseEntity<String> updateProposalsList(@RequestParam("file") MultipartFile proposalUpdateFile) {
        try {
            proposalService.updateProposalsStatus(proposalUpdateFile);
            return ResponseEntity.ok("Bulk records updated successfully.");
        } catch (Exception e) {
            logger.error("Error updating bulk proposals: {}", e.getMessage());
            return ResponseEntity.status(500).body(Constants.MESSAGE_TECHNICAL_ERROR);
        }
    }

    /**
     * Fetch a single Proposal record by ProposalId.
     */
    @GetMapping("/{proposalId}")
    public ResponseEntity<?> getProposalById(@PathVariable String proposalId) {
        try {
            Proposal proposal = proposalService.getProposalById(proposalId);

            if (proposal == null) {
                logger.warn("Proposal with ID {} not found in the database.", proposalId);
                return ResponseEntity.status(404).body(Map.of("message", "Proposal not found", "proposalId", proposalId));
            }

            return ResponseEntity.ok(proposal);
        } catch (Exception e) {
            logger.error("Error fetching proposal ID {}: {}", proposalId, e.getMessage());
            return ResponseEntity.status(500).body(Map.of("message", Constants.MESSAGE_TECHNICAL_ERROR, "error", e.getMessage()));
        }
    }


    /**
     * Fetch all Proposal records.
     */
    @GetMapping("/all")
    public ResponseEntity<List<Proposal>> getAllProposals() {
        try {
            return ResponseEntity.ok(proposalService.getAllProposals());
        } catch (Exception e) {
            logger.error("Error fetching all proposals: {}", e.getMessage());
            return ResponseEntity.status(500).body(List.of());
        }
    }

    /**
     * Fetch status history for a Proposal.
     */
    @GetMapping("/{proposalId}/history")
    public ResponseEntity<?> getProposalStatusHistory(@PathVariable String proposalId) {
        try {
            Proposal proposal = proposalService.getProposalById(proposalId);

            if (proposal == null) {
                logger.warn("Proposal with ID {} not found.", proposalId);
                return ResponseEntity.status(404).body(Map.of("message", "Proposal not found", "proposalId", proposalId));
            }

            List<ProposalStatus> statusHistory = proposalService.getStatusHistory(proposalId);

            if (statusHistory.isEmpty()) {
                logger.warn("No status history found for Proposal ID {}.", proposalId);

                ProposalStatus notFoundStatus = ProposalStatus.builder()
                        .proposalId(proposalId)
                        .previousStatus("N/A")
                        .updatedStatus(Constants.STATUS_NOT_FOUND)
                     //   .createdAt(System.currentTimeMillis())  // Ensure timestamp consistency
                        .build();

                return ResponseEntity.ok(List.of(notFoundStatus));
            }

            return ResponseEntity.ok(statusHistory);
        } catch (Exception e) {
            logger.error("Error fetching status history for Proposal ID {}: {}", proposalId, e.getMessage());
            return ResponseEntity.status(500).body(Map.of("message", Constants.MESSAGE_TECHNICAL_ERROR, "error", e.getMessage()));
        }
    }

}




package com.example.utility1.model;

import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.Field;

import java.util.List;

/**
 * Represents a Product entity stored in MongoDB.
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Document(collection = "ProductCollection")

public class Proposal {

    @Id
    private String id;

    @Field("product_id")
    @Indexed(unique = true)
    private String proposalId;

    @Field("date")
    private String date;

    @Field("product_code")
    private String proposalCode;

    @Field("Product_name")
    private String proposalName;

    @Field("channel")
    private String channel;

    @Field("quoteId")
    private String quoteId;

    @Field("status")
    private String status;

    @Field("payment_mode")
    private String paymentMode;

    @Field("payment_status")
    private String paymentStatus;

    @Field("remarks")
    private String remarks;
    @Field("status_history")
    private List<ProposalStatus> statusHistory;

}





package com.example.utility1.model;

import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.Field;

/**
 * Represents a status change for a Proposal.
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Document(collection = "ProductCollection")

public class ProposalStatus {

    @Id  // This field represents MongoDB's autogenerated unique ID
    private String id;
    @Field("proposal_id")
    private String proposalId;

    @Field("previous_status")
    private String previousStatus;

    @Field("updated_status")
    private String updatedStatus;



}



package com.example.utility1.repository;

import com.example.utility1.model.Proposal;
import com.example.utility1.model.ProposalStatus;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface ProposalRepository extends MongoRepository<Proposal, String> {
    List<Proposal> findByRemarks(String remarks);
 //   List<Proposal> findByProposalId(String proposalId);

    List<Proposal> findByStatus(String status);
    Proposal findByProposalId(String proposalId);


}
package com.example.utility1.repository;

import com.example.utility1.model.ProposalStatus;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProposalStatusRepository extends MongoRepository<ProposalStatus, String> {
    List<ProposalStatus> findByProposalId(String proposalId);
}



package com.example.utility1.service.implement;

import com.example.utility1.constants.Constants;
import com.example.utility1.model.Proposal;
import com.example.utility1.model.ProposalStatus;
import com.example.utility1.repository.ProposalRepository;
import com.example.utility1.repository.ProposalStatusRepository;
import com.example.utility1.service.ProposalService;
import lombok.RequiredArgsConstructor;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.data.mongodb.core.query.Update;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.util.ArrayList;
import java.util.List;

@Service
@RequiredArgsConstructor
public class ProposalServiceImplement implements ProposalService {

    private final ProposalRepository proposalRepository;
    private final ProposalStatusRepository proposalStatusRepository;

    private final MongoTemplate mongoTemplate;
    private static final Logger logger = LoggerFactory.getLogger(ProposalServiceImplement.class);

    @Override
    public List<Proposal> readExcelFile(MultipartFile file) {
        List<Proposal> proposals = new ArrayList<>();

        try (Workbook workbook = new XSSFWorkbook(file.getInputStream())) {
            Sheet sheet = workbook.getSheetAt(0);
            boolean firstRow = true;

            for (Row row : sheet) {
                if (firstRow) {
                    firstRow = false;
                    continue;
                }

                try {
                    Proposal proposal = Proposal.builder()
                            .proposalId(row.getCell(0) != null ? String.valueOf((int) row.getCell(0).getNumericCellValue()) : null)
                            .status(row.getCell(6) != null ? row.getCell(6).getStringCellValue() : "")
                            .remarks(row.getCell(9) != null ? row.getCell(9).getStringCellValue() : "")
                            .build();

                    proposals.add(proposal);
                } catch (Exception e) {
                    logger.error("Error processing row: {}", e.getMessage());
                }
            }

        } catch (Exception e) {
            logger.error("Error reading Excel file: {}", e.getMessage());
        }
        return proposals;
    }
//    @Override
//    public void updateProposalStatusById(String proposalId) {
//        Proposal fetchProposal = getProposalById(proposalId);
//        if (fetchProposal != null && fetchProposal.getRemarks().equalsIgnoreCase(Constants.REMARKS_PURGED)) {
//            fetchProposal.setStatus(Constants.STATUS_REJECTED);
//            mongoTemplate.save(fetchProposal);
//        }
//    }
@Override
public Proposal getProposalById(String proposalId) {
    try {
        Proposal proposal = proposalRepository.findByProposalId(proposalId);
        if (proposal == null) {
            logger.warn("Proposal {} not found in database.", proposalId);
        }
        return proposal;
    } catch (Exception e) {
        logger.error("DB error while fetching proposal {}: {}", proposalId, e.getMessage());
        throw new RuntimeException(Constants.MESSAGE_TECHNICAL_ERROR);
    }
}

    @Override
    public void updateProposalStatusById(String proposalId) {
        Proposal fetchProposal = getProposalById(proposalId);

        if (fetchProposal != null) {
            // Retrieve latest recorded status correctly
            Query query = new Query(Criteria.where("proposalId").is(proposalId))
                    .limit(1)
                    .with(org.springframework.data.domain.Sort.by(org.springframework.data.domain.Sort.Direction.DESC, "createdAt")); // Sorting by most recent timestamp

            ProposalStatus lastStatus = mongoTemplate.findOne(query, ProposalStatus.class);

            // Correctly set previous status from the last recorded update
            String previousStatus = (lastStatus != null) ? lastStatus.getPreviousStatus() : fetchProposal.getStatus();

            // Determine new status
            String updatedStatus = fetchProposal.getRemarks().equalsIgnoreCase(Constants.REMARKS_PURGED)
                    ? Constants.STATUS_REJECTED
                    : Constants.STATUS_INPROGRESS;

            // Update proposal in the database
            fetchProposal.setStatus(updatedStatus);
            mongoTemplate.save(fetchProposal);

            // Save updated status with proper previous status tracking
            ProposalStatus statusRecord = ProposalStatus.builder()
                    .proposalId(proposalId)
                    .previousStatus(previousStatus)  // Now correctly storing the actual last status before this update
                    .updatedStatus(updatedStatus)
                    .build();

            proposalStatusRepository.save(statusRecord);
        } else {
            // If proposal is not found, return "NOT FOUND" status
            ProposalStatus notFoundStatus = ProposalStatus.builder()
                    .proposalId(proposalId)
                    .previousStatus(Constants.STATUS_NOT_FOUND)
                    .updatedStatus(Constants.STATUS_NOT_FOUND)
                    .build();

            proposalStatusRepository.save(notFoundStatus);
        }
    }

    @Override
    public void updateProposalsStatus(MultipartFile ProposalUpdateFile) {
        List<Proposal> Proposals = readExcelFile(ProposalUpdateFile);

        if (Proposals.isEmpty()) {
            logger.warn("No Proposals found in the uploaded file.");
            return;
        }

        Proposals.forEach(Proposal -> {
            Query query = new Query(Criteria.where("ProposalId").is(Proposal.getProposalId()));

            String updatedStatus = "will be purged".equalsIgnoreCase(Proposal.getRemarks())
                    ? Constants.STATUS_REJECTED
                    : Constants.STATUS_INPROGRESS;

            Update update = new Update().set("status", updatedStatus);
            var result = mongoTemplate.updateFirst(query, update, Proposal.class);

            if (result.getModifiedCount() > 0) {
                logger.info("Updated ProposalId: {} â†’ status set to {}", Proposal.getProposalId(), updatedStatus);
            } else {
                logger.warn("No records updated for ProposalId {}", Proposal.getProposalId());
            }
        });

        logger.info("Batch update completed for {} Proposals.", Proposals.size());
    }

    @Override public List<Proposal> createProposals(MultipartFile proposalCreateFile)
    {
        List<Proposal> fetchProposals = new ArrayList<>();
        readExcelFile(proposalCreateFile).forEach(proposal ->
        { logger.info("Processing update for proposalId: {}", proposal.getProposalId());
            fetchProposals.add(mongoTemplate.save(proposal)); }); return fetchProposals; }




    @Override
    public List<Proposal> getProposalsByStatus(String status) {
        return proposalRepository.findByStatus(status);
    }

    @Override
    public List<Proposal> getAllProposals() {
        return proposalRepository.findAll();
    }
//

    @Override
    public List<ProposalStatus> getStatusHistory(String proposalId) {
        try {
            // Fetch the latest recorded status, sorted by timestamp
            Query query = new Query(Criteria.where("proposalId").is(proposalId))
                    .limit(1)
                    .with(org.springframework.data.domain.Sort.by(org.springframework.data.domain.Sort.Direction.DESC, "_id")); // Sort by MongoDB's default `_id`
            ProposalStatus lastStatus = mongoTemplate.findOne(query, ProposalStatus.class);

            if (lastStatus == null) {
                Proposal proposal = proposalRepository.findByProposalId(proposalId);

                if (proposal == null) {
                    logger.warn("Proposal ID {} not found in DB.", proposalId);
                    return List.of(new ProposalStatus(null, proposalId, Constants.STATUS_NOT_FOUND, Constants.STATUS_NOT_FOUND));
                } else {
                   // return List.of(new ProposalStatus(null, proposalId, proposal.getStatus(), proposal.getStatus()));
                    return List.of(new ProposalStatus(null, proposalId, proposal.getStatus(), proposal.getStatus()));
                }
            }

            return List.of(lastStatus); // Return the latest status instead of "INITIAL STATUS"
        } catch (Exception e) {
            logger.error("Database error while fetching status history for Proposal ID {}: {}", proposalId, e.getMessage());
            throw new RuntimeException(Constants.MESSAGE_TECHNICAL_ERROR);
        }
    }



}

1. create an API which takes file path and uploads the file( where to upload the file?)
2. backend java code must read the file from the path and load proposal id's into Arraylist
3. retrieve proposal Json where the status is INPROGRESS, PENDING,  and update the status in MongoDb  proposalcollection
3.1. how to bulk select and update ITERATION 1 IMPLEMENTATION
3.2. how to paginate/batch select and update
4. for every proposal maintain a list of status POJO object which consist of proposal id, previous status and updated status
5. return list of status POJO as part of response to UI call done in step1.
6. if a proposal is not found in mongo db collection, in the status POJO object maintain the status as "NOT FOUND"
7. if there are any exceptions ,inputoutput or db exceptions then return 500  error msg as "technical error bcz of io or db"










